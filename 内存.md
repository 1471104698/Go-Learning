# 内存



## 1、内存占用

> #### 基本数据类型的内存占用

```go
int8、uint8、byte、bool 占用 1B
int16、uint16 占用 2B
int32、uint32、float32、rune 占用 4B
int64、uint64、float64 占用 8B

int 和 uint 具体看 CPU
32位 CPU 占用 4B，等同于 int32
64位 CPU 占用 8B，等同于 int64
现在基本都是 64位 CPU，因此 int 基本上等同于 int64

uintptr 取决于编译器实现
```



64位 CPU 下 int 型变量的大小：

```go
func main() {
	var i int = 1
	fmt.Println(unsafe.Sizeof(i)) // 8
}
```





> #### 结构体内存占用

```
type T struct {
	a bool  //1
	b int32 //4
	c int8  //1
	d int64 //8
	e byte  //1
	// 15
}

func main() {
	var t T

	fmt.Printf("a: %d  b: %d  c: %d  d: %d  e: %d\n",
		unsafe.Sizeof(t.a), unsafe.Sizeof(t.b), unsafe.Sizeof(t.c), unsafe.Sizeof(t.d), unsafe.Sizeof(t.e))
	fmt.Printf("所有变量理论占用内存大小：%d\n",
		unsafe.Sizeof(t.a)+unsafe.Sizeof(t.b)+unsafe.Sizeof(t.c)+unsafe.Sizeof(t.d)+unsafe.Sizeof(t.e))

	fmt.Printf("实际结构体占用内存大小 sizeof：%d\n", unsafe.Sizeof(t)) // 8
}
```

输出结果：

```go
a: 1  b: 4  c: 1  d: 8  e: 1
所有变量理论占用内存大小：15
实际结构体占用内存大小 sizeof：32
```



可以看出，理论上结构体的内存占用应该是内部所有变量的内存占用总和，应该是 15B，但是实际上它占用了 32B

这是因为 golang 结构体是一个连续的内存空间，而 CPU 读取不是 一个字节一个字节读取的，它是以块为单位进行读取的，块可以是 1B、2B、4B、8B、16B 等如果某个块被该结构体占用了一部分，但是没有完全占用，那么剩下的空余部分也会分配到该结构体上，不会存储其他数据，即内存对齐

我们需要知道它是按照什么样的规则进行内存对齐的



## 2、内存对齐

首先内存对齐有以下两个规则：

- 变量的偏移起始地址 是 对齐保证 的整数倍
- 变量的内存占用大小 是 对齐保证 的整数倍



什么是对齐保证？

```go
对齐保证是变量分配内存时的依据，结构体中变量的内存地址和内存占用不是随意分配的，分配的内存地址是按照对齐保证根据一定规则来进行分配的

通过 unsafe.Alignof() 可以获取对齐保证的值
```



> #### 1 中例子解读

```go
type T struct {
	a bool  //1
	b int32 //4
	c int8  //1
	d int64 //8
	e byte  //1
	// 15
}

func main() {
	var t T

	fmt.Printf("t 中实际占用内存大小：%d， 对齐保证：%d\n", unsafe.Sizeof(t), unsafe.Alignof(t))
	fmt.Printf("a 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.a), unsafe.Alignof(t.a), unsafe.Offsetof(t.a))
	fmt.Printf("b 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.b), unsafe.Alignof(t.b), unsafe.Offsetof(t.b))
	fmt.Printf("c 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.c), unsafe.Alignof(t.c), unsafe.Offsetof(t.c))
	fmt.Printf("d 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.d), unsafe.Alignof(t.d), unsafe.Offsetof(t.d))
	fmt.Printf("e 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.e), unsafe.Alignof(t.e), unsafe.Offsetof(t.e))
}
```

输出结果：

```go
t 中实际占用内存大小：32， 对齐保证：8
a 占用内存大小：1， 对齐保证：1, 内存地址偏移量：0	（内存占用大小和内存地址偏移量都是对齐保证的整数倍， 0倍也算）
b 占用内存大小：4， 对齐保证：4, 内存地址偏移量：4
c 占用内存大小：1， 对齐保证：1, 内存地址偏移量：8
d 占用内存大小：8， 对齐保证：8, 内存地址偏移量：16
e 占用内存大小：1， 对齐保证：1, 内存地址偏移量：24
```

上面变量中，都遵循了内存对齐的两个规则，同时也是因为遵循了这两个规则，导致它们实际占用的内存大小超过了几个变量内存占用的总和，

除开它们数据占用的内存外，还有部分内存是用来内存对齐，

接下来进行解析：

```go
a 占用内存大小：1， 对齐保证：1, 内存地址偏移量：0
b 占用内存大小：4， 对齐保证：4, 内存地址偏移量：4
	// a 内存占用大小为 1，内存偏移量为 0，那么理论上下一个变量的内存地址偏移量应该为 1，但实际上 b 的内存地址偏移量为 4
	// 这是因为 b 占用内存大小为 4，而内存大小必须是对齐保证的整数倍，实际上这里看作是反作用，由于内存大小为 4，那么就意味着对齐保证必须是 4 以上
	// 因此 b 的内存地址偏移量也必须是 4 以上，那么满足要求的最小内存地址偏移量就是 4 了，因此 b 的内存地址偏移量不是 1 而是 4
	// 也因此，导致 [1, 3] 之间的内存是空余的，浪费了 3byte


c 占用内存大小：1， 对齐保证：1, 内存地址偏移量：8
d 占用内存大小：8， 对齐保证：8, 内存地址偏移量：16
	// c 内存地址偏移量为 8 是因为 b 内存大小 + b 内存地址偏移量 = 8，所以没问题
	// c 占用内存为 1，内存偏移量为 8，那么理论上下一个变量的内存地址偏移量应该为 9，但实际上 b 的内存地址偏移量为 16
	// 理由同上
	// 因此导致 [9, 15] 间的内存是空余的，浪费了 7byte

e 占用内存大小：1， 对齐保证：1, 内存地址偏移量：24
	// 内存占用没问题，内存地址偏移量也是根据 d 来计算的
	// 最终总的内存大小占用为 25
	// 但是因为结构体的对齐保证为 8，因此结构体整体的内存占用大小必须是 8 的整数倍，因此需要再填充 7byte，变成 32
	
```

综上，理论上占用 15byte 的数据由于内存分配规则变成了 32byte

但是，我们也可以利用这个规则，通过调整变量的位置来减少空余内存的占用大小，因为结构体的变量分布是严格按照我们定义的变量顺序来分配的



> #### 修改变量位置来减少空余内存占用例子

```go
type T struct {
	a bool  //1
	b int32 //4
	c int8  //1
	e byte  //1
	d int64 //8
	// 15
}

func main() {
	var t T

	fmt.Printf("t 中实际占用内存大小：%d， 对齐保证：%d\n", unsafe.Sizeof(t), unsafe.Alignof(t))
	fmt.Printf("a 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.a), unsafe.Alignof(t.a), unsafe.Offsetof(t.a))
	fmt.Printf("b 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.b), unsafe.Alignof(t.b), unsafe.Offsetof(t.b))
	fmt.Printf("c 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.c), unsafe.Alignof(t.c), unsafe.Offsetof(t.c))
	fmt.Printf("e 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.e), unsafe.Alignof(t.e), unsafe.Offsetof(t.e))
	fmt.Printf("d 占用内存大小：%d， 对齐保证：%d, 内存地址偏移量：%d\n", unsafe.Sizeof(t.d), unsafe.Alignof(t.d), unsafe.Offsetof(t.d))
}
```

输出结果：

```go
t 中实际占用内存大小：24， 对齐保证：8
a 占用内存大小：1， 对齐保证：1, 内存地址偏移量：0
b 占用内存大小：4， 对齐保证：4, 内存地址偏移量：4
c 占用内存大小：1， 对齐保证：1, 内存地址偏移量：8
e 占用内存大小：1， 对齐保证：1, 内存地址偏移量：9
d 占用内存大小：8， 对齐保证：8, 内存地址偏移量：16
```

可以看出，通过调整变量 d 和 e 的位置，使得内存偏移量 9 能够正常使用，避免了 [9, 15] 间内存的浪费

因此，**当由于某个结构体变量大量创建导致 GC 时，可以考虑下调整变量的位置来减少内存占用，以此减少 GC**