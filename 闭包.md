# 闭包



## 1、一等公民概念

一个实体如果能够进行参数传递、作为返回值返回、赋值给变量，那么这个实体就是一等公民

比如 int 类型，它能够进行参数传递，作为返回值，能够赋值，因此它是一等公民

同理，在 golang 中，函数类型 func 它也能够实现这几种功能，因此函数 func 也是一等公民



## 2、闭包概念

wiki 解释：

```go
一个函数作为返回值，并且在它内部引用了父函数的值，那么该函数形成了闭包
```

比如父函数内定义了变量 i，然后它返回的函数中引用了这个变量 i，那么这就形成了闭包



## 3、函数闭包例子

### 3.1、普通闭包

```go
// 闭包一
func fatherFunc(a int) func(int) (int, error) {
	return func(i int) (int, error) {
		fmt.Println(i)
		return a, nil
	}
}

func main() {
	fn := fatherFunc(2)
	a, err := fn(3)
	if err == nil {
		fmt.Println(a)
	}
}
```



### 3.2、嵌套闭包

```go
// 闭包二：多层嵌套
type handleFunc1 func() handleFunc2
type handleFunc2 func(string) error

func fatherFunc2(a int) handleFunc1 {
	return func() handleFunc2 {
        str := strconv.Itoa(a)
		return func(s string) error {
			if s != str {
                fmt.Println("err")
				return errors.New("not same")
			}
			return nil
		}
	}
}

func main() {
	son1 := fatherFunc2(2)
	son2 := son1()
	err := son2("21") // err
	if err != nil {
		fmt.Println(err)
	}
}
```



## 4、匿名函数是闭包吗？



```
func main() {
	a := 1
	
	fn := func() {
		fmt.Println(a)
	}
}
```

上面的程序算是闭包吗？

根据 wilki 的话不算，因为该匿名函数不是作为返回值返回的，但是在 golang 官方给出的案例中，这种其实算是闭包的



golang 官方对匿名函数的闭包解释：

```go
func main() {
	done := make(chan bool)

	values := []string{"a", "b", "c"}
	for _, v := range values {
		// 闭包
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}

	// wait for all goroutines to complete before exiting
	for _ = range values {
		<-done
	}
}
```



因此，在 golang 中，匿名函数引用外部的值也算是闭包