# GO 调度



## 用户线程和OS线程、CPU 的关系

首先我们需要明白，在 Linux 中线程的概念实际上就是轻量级进程，我们把它叫做 OS 线程/ 内核线程

对于 CPU 来说，它只能调度的是 OS 线程，并不能感知到用户线程的存在，因此，CPU 执行的是什么任务，具体看 OS 线程

CPU 跟 OS 线程绑定，OS 线程能够跟用户线程进行绑定，相当于 OS 线程是 CPU 和 用户线程沟通的桥梁

OS 线程和用户线程绑定相当于是 用户线程将任务交给 OS 线程去执行，CPU 和 OS 线程绑定相当于是 CPU 去执行 OS 线程内的任务，换句话说，在 CPU 看来它虽然是在执行 OS 线程的任务，但是实际上 OS 线程的任务是用户线程的，即它实际上是在执行用户线程的任务，不过它感知不到



> #### 例子说明

```
游戏里有一座城池，CPU 是城池内的玩家，负责领取并完成任务，OS 线程负责从城池外部接收别人的委托，用户线程是城池外的人向城池内的人提供委托（这里的委托就是我们让线程执行的任务）

OS 线程会接收城池外的用户线程的委托，将委托放在自己这里，然后 CPU 来 OS 线程这里领取委托去完成
我们可以理解为每个任务内部都是一行行的有顺序的二进制指令，CPU 根据顺序去执行这些指令，执行完全部指令这个任务也就完成了
```

在这里 CPU 是不知道任务是哪个用户线程发出的，它能看到的只有 OS 线程，或者说 CPU 感知不到用户线程的存在



> #### 关于 OS 线程作用的个人推测的一个点（只是有可能包含这一点）

个人感觉 CPU 直接调度 OS 线程的话是为了适配不同类型的用户线程，OS 线程类似于一个抽象接口，CPU 调度的就是这个统一的接口，它并不关心用户线程是 Java 线程还是 Go 协程，只要这些用户线程适配 OS 线程能够跟 OS 线程绑定即可，这样对于 CPU 来说也是屏蔽了不同用户线程实现的差异



## 调度方式

目前线程调度模型存在三种：

1. 用户级线程模型
2. 内核级线程模型
3. 两级线程模型



> ####  用户级线程模型 N：1

一个 OS 线程对应 N 个用户线程，所有的用户线程都由该 OS 线程控制，一个 CPU 核心 只需要执行同一个 OS 线程，而该 OS 线程具体的执行内容由和它当前绑定的用户线程决定

一个用户进程里无论存在多少个用户线程，它始终都是只一个 OS 线程进行绑定，线程的创建和销毁都是由用户自己的线程库来实现的（比如 Java 有自己的线程库，它如果使用 N:1 模型的话那么这些用户线程创建和销毁都是它自己来管理），**无需使用系统调用，不需要涉及到内核**，并且线程上下文切换也只会涉及到用户线程，不会涉及到内核，减少成本

问题在于，CPU 每次只能跟一个用户进程进行绑定，它的眼里实际上只有与用户进程绑定的那个 OS 线程，而没有什么用户线程，它至始至终都是在执行那个 OS 线程，而一旦与 OS 线程绑定的用户线程进入阻塞状态，那么就会导致整个用户进程的所有线程都被阻塞，因为用户进程内的线程调度是不存在 CPU 中断的，因此此时整个用户进程被挂起，与之绑定的 OS 线程也陷入阻塞状态，那么会导致用户进程其他线程无法执行，CPU 中断/轮转 也会放弃该 OS 线程，进行内核态上下文切换去执行其他的 OS 线程

```
因此，后面大多的协程库都是在阻塞的点实现非阻塞，在阻塞时用户线程主动让出，让其他用户线程跟OS线程进行绑定，这样可以避免用户进程阻塞，导致OS线程阻塞，导致 CPU 发生内核上下文切换，可以继续执行
```



优点：上下文切换的成本低，一般情况下，减少内核上下文切换

缺点：无法利用 CPU 多核，一个用户进程多个任务并发执行也只能利用一个 CPU 核心



> #### 内核级线程模型 1：1

一个 OS 线程对应一个用户线程

一个用户进程内多个用户线程，每个用户线程都绑定一个 OS 线程，这种的用户线程基本就是对 OS 线程的封装，比如 Java 的 Thread，每创建一个线程实际上就是创建一个 OS 线程，返回得到的 Thread 是对这个 OS 线程的封装。线程的创建和销毁都是交给内核来完成，成本比较高

这种模型由于一个用户进程对应多个 OS 线程，CPU 可以直接借助操作系统来完成对 OS 线程的调度，来完成 OS 线程的快速切换，并且在多核CPU上，可以同时执行用户进程中与之绑定的多个OS线程，真正达到并行计算的优点



优点：利用 CPU 多核，一次能够并行执行多个线程，并且不存在用户级线程模型一个线程阻塞就导致整个用户进程阻塞的问题

缺点：线程创建和销毁、线程上下文切换等都依赖内核，成本高，每次切换用户线程实际上就是在切换 OS 线程

【目前 Java 调度模型使用的就是这一种】



> ####  两级线程模型 N：M

N 个 OS 线程对应 M 个用户线程

这个模型集合了上面两个模型的优点：

1、首先区别于用户级线程模型，用户进程中的每个用户线程都可以跟一个 OS 线程进程绑定，这点类似于内核级线程模型

2、其次区别于内核级线程模型，用户进程中的多个用户线程可以绑定同一个 OS 线程，当某个 OS 线程因为阻塞而被 CPU 停止调度时，OS 线程可以跟其他的用户线程进行绑定，然后继续等待 CPU 进行调度

它这种模型是比较灵活的，相比 N:1 模型，OS 线程阻塞了也不会导致整个用户进程阻塞，因为它存在多个 OS 线程，一个 OS 线程阻塞了也可能去调度其他的 OS  线程，同时它阻塞的 OS 线程还可以再去绑定其他未阻塞的用户线程；相比 1:1 模型，多个用户线程可以绑定一个 OS 线程，减少了线程的上下文切换以及创建和销毁的成本

```
比如存在 CPU 核心 1 2，OS线程 1 2，用户线程 1 2 3 4。 CPU 核心 1 目前跟 OS 线程 1 绑定，CPU 核心 2 目前跟 OS 线程 2 绑定，我将 用户线程 1 2 分配给 OS线程 1,将用户线程 3 4 分配给 OS 线程 2，这样既能够利用到 多核 CPU，如果用户线程1 停止执行了，那么只需要将 OS 线程1 跟 用户线程2 进行绑定即可，CPU 

核心 1 和 OS 线程 1 之间并不需要进行解绑，即不需要发生 OS 线程的上下文切换
```

【目前 GO 调度模型使用的就是这一种】



## GO 调度模型-GMP

G：

```
goroutine，指代 go 线程，是用户线程级别的
```



M：

```
Machine，指代 OS 线程，是内核线程级别的
```



P：

```
Processor，抽象的 CPU 处理核心，每一个 P 都相当于一个 CPU 核心，P 的数量不得超过 CPU 核心数
```



GO 调度模型的三级队列：

![image.png](https://pic.leetcode-cn.com/1624004610-wGnFAI-image.png)



P 与 M 绑定后会从 P 所具有的 G 中选择一个 G 来执行，P 会调度 M 去执行这个 G，此时 P 和 M 是绑定的

 一般情况下，P 的数量等于 CPU 核心数 N ，M 的数量可以 >= P，但是**一个 P 同一时间只会跟一个 M 进行绑定**，即同一时间有多少个 P 那么就只能有多少个 M 在自旋/执行

按照数量来看的话，P 的最大数量 = CPU 核心数 <= M 的数量 <= G 的数量

![img](https://static.studygolang.com/190608/77826ccf4195fb1216becf383302af10.png)

在上面图1 ，如果任务 g8 进入阻塞状态，那么

