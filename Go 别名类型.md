# Go 别名类型



## 引言

这里的别名不是说以下这种方式定义的别名：

```go
type f func() error
```



## 问题引入

首先存在以下三行代码：

```go
// 32 位机器
1）var x int32 = 32.0
2）var y int = x
3）var z rune = x
```

结果如何？编译是否能够通过？



## 数字字面量

在 go 中所有的数字字面量都是**无类型常量**，即它们是没有任何类型的，相对来说它们可以是任意数字类型，**可以赋值给任意数字的类型**

即下面的这些代码变异都能够通过：

```go
var a int64 = 32.0
var b int = 32.0
var c float32 = 32.0
var d complex64 = 32.0
var e byte = 32.0
var f rune = 32.0
```

因此 1）能够编译通过



## 不同类型的赋值转换

在 go 中是不支持隐式类型转换的，即我们可以理解为只要类型不同，那么它们之间的赋值就必须显式地进行强转。

2）中 y 是 int 类型，x 是 int32 类型，其中 int 所占字节大小是不固定的，在 32位机器上它占用 4B，在 64位机器上它占用 8B，而题目说的环境是在 32位机器上，所以 int 占 4B，而 int32 也是占 4B，虽然它们占用内存大小相同，但是它们的**数据类型不同，因此不能直接赋值**，因此编译错误

需要修改为以下代码：

```go
var y int = int(x)
```

因此 2）不能编译通过



## 别名

在 go 中有两种都不同意义上的别名定义方式：

```go
1）type I int
2）type II = int
```

1）中是定义的 I 它可以看作是一种新的类型，虽然它底层是 int，但是 go 会把它当作一种新的类型来处理

它跟 int 唯一共通的点就是它们之间能够进行类型转换，**转换需要显式强转**

```go
func main() {
    var i int = 1
    eat(I(i))
}

func eat(i I) {}
```

同时由于是新的类型，可以以该类型去实现某些方法：

```go
func (I) eat() {}
```



2）中定义的是 II 它不能看作是一种新的类型，它仍然是 int 类型，可以在任何地方代替 int 出现，它们之间是等同的，我们可以理解为这是真正意义上的别名

它和 int 之间能够任意进行的转换

```go
func main() {
    var i int = 1
    eat(i)
}

func eat(i II) {}
```

不过这种别名无法用来实现方法，比如以下代码会编译错误：

```go
func (II) eat() {}
```



现在我们重新来看看 rune 类型的定义：

```go
type rune = int32
```

在 go 中 rune 是 int32 的别名，因此它是等同于 int32 的

因此 3）编译通过



与 rune 类似的还有 byte

```go
type byte = uint8
```



即 rune 等同于 int32，byte 等同于 uint8